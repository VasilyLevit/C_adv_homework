/* Задача 4. Шифр Цезаря
На стандартном потоке ввода задается целое неотрицательное число N и последовательность допустимых символов в кодировке ASCII, оканчивающаяся точкой. Допустимые символы – латинские буквы 'a' ... 'z', 'A' ... 'Z' и пробел. Требуется закодировать латинские буквы ('a' ... 'z', 'A' ... 'Z') шифром Цезаря, пробелы вывести без изменения. Число N задает сдвиг в шифре. Шифр Цезаря заключается в следующем преобразовании. Пусть буквы алфавита пронумерованы от 0 до K - 1, где K - число символов в алфавите. Тогда символ с номером n кодируется символом с номером p = (n + N) mod K (mod - операция взятия остатка). На стандартном потоке вывода напечатать зашифрованное сообщение, оканчивающееся точкой. Преобразование требуется выполнять независимо для заглавных и строчных латинских букв.

Указание: использовать массивы запрещается.
Данные на входе: Натуральное число N (N > 0), после которого следует сообщение.
Данные на выходе: Зашифрованное сообщение.
Пример No1
Данные на входе: 0 Hello World.
Данные на выходе: Hello World.
Пример No2
Данные на входе: 1 Aa.
Данные на выходе: Bb.  */


#include<stdio.h>

char cifer(char, unsigned);

int main()
{
    unsigned n;
    char ch;
    printf("Input N: ");
    scanf("%u", &n);
    while ('.' != (ch = getchar()))
    {
        putchar(cifer(ch, n));
    }
    putchar('.');
    putchar('\n');
    return 0;
}

char cifer(char ch, unsigned n)
{
    char base;
    const char range = 'z' - 'a' + 1;
    char shift = n % range;  // чтобы избежать переполнения

    if(ch >= 'a' && ch <= 'z')
    {
        base = 'a';
    }
    else if(ch >= 'A' && ch <= 'Z')
    {
        base = 'A';
    }
    else
    {
        return ch;
    }
    return base + ((ch + shift - base) % range);
}